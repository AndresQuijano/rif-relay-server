(()=>{"use strict";var e={472:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.HttpServer=void 0;const n=a(r(127)),s=a(r(144)),i=a(r(473)),o=a(r(479)),c=a(r(732));t.HttpServer=class{constructor(e,t){this.port=e,this.backend=t,this.app=n.default(),this.app.use(o.default()),this.app.use(i.default.urlencoded({extended:!1})),this.app.use(i.default.json()),this.app.post("/",this.rootHandler.bind(this)),this.app.get("/getaddr",this.pingHandler.bind(this)),this.app.get("/status",this.statusHandler.bind(this)),this.app.get("/tokens",this.tokenHandler.bind(this)),this.app.get("/verifiers",this.verifierHandler.bind(this)),this.app.post("/relay",this.relayHandler.bind(this)),this.backend.once("removed",this.stop.bind(this)),this.backend.once("unstaked",this.close.bind(this)),this.backend.on("error",(e=>{console.error("httpServer:",e)}))}start(){void 0===this.serverInstance&&(this.serverInstance=this.app.listen(this.port,(()=>{console.log("Listening on port",this.port),this.startBackend()})))}startBackend(){try{this.backend.start()}catch(e){c.default.error("relay task error",e)}}stop(){var e;null===(e=this.serverInstance)||void 0===e||e.close(),console.log("Http server stopped.\nShutting down relay...")}close(){console.log("Stopping relay worker..."),this.backend.stop()}async rootHandler(e,t){var r;let a;try{let t;const n=this.backend[e.body.method];if(null==n)throw Error(`Implementation of method ${e.body.params} not found on backend!`);t=null!==(r=await n.apply(this.backend,[e.body.params]))&&void 0!==r?r:{code:200},a=s.default.success(e.body.id,t)}catch(t){let r=t.stack.toString();r=r.replace(/(rootHandler.*)[\s\S]*/,"$1"),a=s.default.error(e.body.id,new s.default.JsonRpcError(r,-125))}t.send(a)}async pingHandler(e,t){try{const r=await this.backend.pingHandler(e.query.verifier);t.send(r),console.log(`address ${r.relayWorkerAddress} sent. ready: ${r.ready}`)}catch(e){const r=e.message;t.send({message:r}),c.default.error(`ping handler rejected: ${r}`)}}statusHandler(e,t){t.status(204).end()}async relayHandler(e,t){try{const r=(await this.backend.createRelayTransaction(e.body)).signedTx;t.send({signedTx:r})}catch(e){t.send({error:e.message}),console.log("tx failed:",e)}}async tokenHandler(e,t){try{const r=e.query.verifier,a=await this.backend.tokenHandler(r);t.send(a)}catch(e){const r=e.message;t.send({message:r}),c.default.error(`token handler rejected: ${r}`)}}async verifierHandler(e,t){try{const e=await this.backend.verifierHandler();t.send(e)}catch(e){const r=e.message;t.send({message:r}),c.default.error(`verified handler rejected: ${r}`)}}}},959:function(e,t,r){var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.KeyManager=t.KEYSTORE_FILENAME=void 0;const o=s(r(364)),c=i(r(747)),d=i(r(349)),l=r(784);t.KEYSTORE_FILENAME="keystore",t.KeyManager=class{constructor(e,r,a){if(this._privateKeys={},this.nonces={},d.default(e,d.default.number),null!=a&&null!=r)throw new Error("Can't specify both seed and workdir");if(null!=r)try{let e;c.default.existsSync(r)||c.default.mkdirSync(r,{recursive:!0});const a=r+"/"+t.KEYSTORE_FILENAME;c.default.existsSync(a)?e=Buffer.from(JSON.parse(c.default.readFileSync(a).toString()).seed,"hex"):(e=o.default.generate().getPrivateKey(),c.default.writeFileSync(a,JSON.stringify({seed:e.toString("hex")}),{flag:"w"})),this.hdkey=o.hdkey.fromMasterSeed(e)}catch(e){if(!e.message.includes("file already exists"))throw e}else null==a&&(a=o.default.generate().getPrivateKey()),this.hdkey=o.hdkey.fromMasterSeed(null!=a?a:Buffer.from(""));this.generateKeys(e)}generateKeys(e){this._privateKeys={},this.nonces={};for(let t=0;t<e;t++){const e=this.hdkey.deriveChild(t).getWallet(),r=l.toHex(e.getAddress());this._privateKeys[r]=e.getPrivateKey(),this.nonces[t]=0}}getAddress(e){return this.getAddresses()[e]}getAddresses(){return Object.keys(this._privateKeys)}isSigner(e){return null!=this._privateKeys[e]}signTransaction(e,t){d.default(e,d.default.string);const r=this._privateKeys[e];if(void 0===r)throw new Error(`Can't sign: signer=${e} is not managed`);return t.sign(r),"0x"+t.serialize().toString("hex")}}},93:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.RegistrationManager=void 0;const n=a(r(732)),s=r(784),i=r(51),o=r(565),c=a(r(242)),d=i.defaultEnvironment.mintxgascost;t.RegistrationManager=class{constructor(e,t,r,a,n,o,c){this._isStakeLocked=!1,this.isInitialized=!1,this.delayedEvents=[];const d=()=>{this.printNotRegisteredMessage()};this.balanceRequired=new i.AmountRequired("Balance",s.toBN(n.managerMinBalance),d),this.stakeRequired=new i.AmountRequired("Stake",s.toBN(n.managerMinStake),d),this.contractInteractor=e,this.hubAddress=n.relayHubAddress,this.managerAddress=o,this.workerAddress=c,this.eventEmitter=a,this.transactionManager=t,this.txStoreManager=r,this.config=n}get isStakeLocked(){return this._isStakeLocked}set isStakeLocked(e){const t=this._isStakeLocked;this._isStakeLocked=e,e!==t&&(n.default.info(`Manager stake is ${e?"now":"no longer"} locked`),this.printNotRegisteredMessage())}async init(){null==this.lastWorkerAddedTransaction&&(this.lastWorkerAddedTransaction=await this._queryLatestWorkerAddedEvent()),null==this.lastMinedRegisterTransaction&&(this.lastMinedRegisterTransaction=await this._queryLatestRegistrationEvent()),this.isInitialized=!0}async handlePastEvents(e,t,r,a){if(!this.isInitialized)throw new Error("RegistrationManager not initialized");const n=[i.address2topic(this.managerAddress)],s={fromBlock:t+1,toBlock:"latest"},c=[i.StakeAdded,i.StakeUnlocked,i.StakeWithdrawn],d=await this.contractInteractor.getPastEventsForStakeManagement(c,n,s);this.printEvents(d,s);let l=[];for(const e of d)switch(e.event){case i.StakeAdded:await this.refreshStake();break;case i.StakeUnlocked:await this.refreshStake(),this.delayedEvents.push({block:e.returnValues.withdrawBlock.toString(),eventData:e});break;case i.StakeWithdrawn:await this.refreshStake(),l=l.concat(await this._handleStakeWithdrawnEvent(e,r))}for(const t of e)switch(t.event){case i.RelayServerRegistered:(null==this.lastMinedRegisterTransaction||i.isSecondEventLater(this.lastMinedRegisterTransaction,t))&&(this.lastMinedRegisterTransaction=t);break;case i.RelayWorkersAdded:(null==this.lastWorkerAddedTransaction||i.isSecondEventLater(this.lastWorkerAddedTransaction,t))&&(this.lastWorkerAddedTransaction=t)}for(const e of this._extractDuePendingEvents(r))switch(e.event){case i.StakeUnlocked:l=l.concat(await this._handleStakeUnlockedEvent(e,r))}const u=await this._isRegistrationCorrect();return(!await this.txStoreManager.isActionPending(o.ServerAction.REGISTER_SERVER)&&!u||a)&&(l=l.concat(await this.attemptRegistration(r))),l}_extractDuePendingEvents(e){const t=this.delayedEvents.filter((t=>t.block<=e)).map((e=>e.eventData));return this.delayedEvents=[...this.delayedEvents.filter((t=>t.block>e))],t}_isRegistrationCorrect(){return i.isRegistrationValid(this.lastMinedRegisterTransaction,this.config,this.managerAddress)}async _queryLatestRegistrationEvent(){const e=i.address2topic(this.managerAddress),t=await this.contractInteractor.getPastEventsForHub([e],{fromBlock:1},[i.RelayServerRegistered]);return i.getLatestEventData(t)}_parseEvent(e){if(void 0===(null==e?void 0:e.events))return`not event: ${null==e?void 0:e.toString()}`;const t={};for(const r of e.events)t[r.name]=r.value;return{name:e.name,address:e.address,args:t}}async _handleStakeWithdrawnEvent(e,t){return n.default.warn("Handling StakeWithdrawn event:",e),await this.withdrawAllFunds(!0,t)}async _handleStakeUnlockedEvent(e,t){return n.default.warn("Handling StakeUnlocked event:",e),await this.withdrawAllFunds(!1,t)}async withdrawAllFunds(e,t){let r=[];return r=r.concat(await this._sendWorkersEthBalancesToOwner(t)),e&&(r=r.concat(await this._sendManagerEthBalanceToOwner(t))),this.eventEmitter.emit("unstaked"),r}async refreshBalance(){const e=await this.contractInteractor.getBalance(this.managerAddress);this.balanceRequired.currentValue=s.toBN(e)}async refreshStake(){const e=await this.contractInteractor.getStakeInfo(this.managerAddress),t=s.toBN(e.stake);t.eq(s.toBN(0))||(this.isStakeLocked="0"===e.withdrawBlock,this.stakeRequired.currentValue=t,null==this.ownerAddress&&(this.ownerAddress=e.owner,n.default.info("Got staked for the first time"),this.printNotRegisteredMessage()))}async addRelayWorker(e){const t=await this.contractInteractor.getAddRelayWorkersMethod([this.workerAddress]),r=await this.transactionManager.attemptEstimateGas("AddRelayWorkers",t,this.managerAddress),a={signer:this.managerAddress,gasLimit:r,serverAction:o.ServerAction.ADD_WORKER,method:t,destination:this.hubAddress,creationBlockNumber:e},{transactionHash:n}=await this.transactionManager.sendTransaction(a);return n}async attemptRegistration(e){if(!(this.isStakeLocked&&this.stakeRequired.isSatisfied&&this.balanceRequired.isSatisfied))return n.default.info("Not all prerequisites for registration are met yet. Registration attempt cancelled"),[];let t=[];const r=this._isWorkerValid(),a=await this.txStoreManager.isActionPending(o.ServerAction.ADD_WORKER);if(!r&&!a){const r=await this.addRelayWorker(e);t=t.concat(r)}const s=this.config.url.indexOf(":")>0,i=this.config.url+(!s&&this.config.port>0?":"+this.config.port.toString():""),c=await this.contractInteractor.getRegisterRelayMethod(i),d=await this.transactionManager.attemptEstimateGas("RegisterRelay",c,this.managerAddress),l={serverAction:o.ServerAction.REGISTER_SERVER,gasLimit:d,signer:this.managerAddress,method:c,destination:this.hubAddress,creationBlockNumber:e},{transactionHash:u}=await this.transactionManager.sendTransaction(l);return t=t.concat(u),n.default.debug(`Relay ${this.managerAddress} registered on hub ${this.hubAddress}. `),t}async _sendManagerEthBalanceToOwner(e){const t=await this.contractInteractor.getGasPrice(),r=[],a=d,i=s.toBN(a).mul(s.toBN(t)),c=s.toBN(await this.contractInteractor.getBalance(this.managerAddress));if(c.gte(i)){n.default.info(`Sending manager RBTC balance ${c.toString()} to owner`);const d={signer:this.managerAddress,serverAction:o.ServerAction.VALUE_TRANSFER,destination:this.ownerAddress,gasLimit:a,gasPrice:t,value:s.toHex(c.sub(i)),creationBlockNumber:e},{transactionHash:l}=await this.transactionManager.sendTransaction(d);r.push(l)}else n.default.error(`manager balance too low: ${c.toString()}, tx cost: ${a*parseInt(t)}`);return r}async _sendWorkersEthBalancesToOwner(e){const t=[],r=await this.contractInteractor.getGasPrice(),a=d,i=s.toBN(a*parseInt(r)),c=s.toBN(await this.contractInteractor.getBalance(this.workerAddress));if(c.gte(i)){n.default.info(`Sending workers' RBTC balance ${c.toString()} to owner`);const d={signer:this.workerAddress,serverAction:o.ServerAction.VALUE_TRANSFER,destination:this.ownerAddress,gasLimit:a,gasPrice:r,value:s.toHex(c.sub(i)),creationBlockNumber:e},{transactionHash:l}=await this.transactionManager.sendTransaction(d);t.push(l)}else n.default.info(`balance too low: ${c.toString()}, tx cost: ${a*parseInt(r)}`);return t}async _queryLatestWorkerAddedEvent(){const e=await this.contractInteractor.getPastEventsForHub([i.address2topic(this.managerAddress)],{fromBlock:1},[i.RelayWorkersAdded]);return i.getLatestEventData(e)}_isWorkerValid(){return null!=this.lastWorkerAddedTransaction&&this.lastWorkerAddedTransaction.returnValues.newRelayWorkers.map((e=>e.toLowerCase())).includes(this.workerAddress.toLowerCase())}async isRegistered(){const e=this._isRegistrationCorrect();return this.stakeRequired.isSatisfied&&this.isStakeLocked&&e}printNotRegisteredMessage(){var e;if(this._isRegistrationCorrect())return;const t=`\nNot registered yet. Prerequisites:\n${this.balanceRequired.description}\n${this.stakeRequired.description}\nStake locked   | ${i.boolString(this.isStakeLocked)}\nManager        | ${this.managerAddress}\nWorker         | ${this.workerAddress}\nOwner          | ${null!==(e=this.ownerAddress)&&void 0!==e?e:c.default.red("k256")}\n`;n.default.info(t)}printEvents(e,t){var r;if(0!==e.length){n.default.info(`Handling ${e.length} events emitted since block: ${null===(r=t.fromBlock)||void 0===r?void 0:r.toString()}`);for(const t of e)n.default.info(`\nName      | ${t.event.padEnd(25)}\nBlock     | ${t.blockNumber}\nTxHash    | ${t.transactionHash}\n`)}}}},723:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.RelayServer=void 0;const n=a(r(242)),s=a(r(732)),i=a(r(349)),o=r(784),c=r(51),d=r(851),l=r(93),u=r(516),h=r(565),g=r(72),f=r(519),y=a(r(614)),w="2.0.1";class m extends y.default{constructor(e,t){super(),this.lastScannedBlock=0,this.lastRefreshBlock=0,this.ready=!1,this.lastSuccessfulRounds=Number.MAX_SAFE_INTEGER,this.gasPrice=0,this._workerSemaphoreOn=!1,this.alerted=!1,this.alertedBlock=0,this.initialized=!1,this.trustedVerifiers=new Set,this.versionManager=new c.VersionsManager(w),this.config=g.configureServer(e),this.contractInteractor=t.contractInteractor,this.txStoreManager=t.txStoreManager,this.transactionManager=new u.TransactionManager(t,this.config),this.managerAddress=this.transactionManager.managerKeyManager.getAddress(0),this.workerAddress=this.transactionManager.workersKeyManager.getAddress(0),this.customReplenish=this.config.customReplenish,this.workerBalanceRequired=new c.AmountRequired("Worker Balance",o.toBN(this.config.workerMinBalance)),this.printServerAddresses(),s.default.setLevel(this.config.logLevel),s.default.warn("RelayServer version",w),s.default.info("Using server configuration:\n",this.config)}printServerAddresses(){s.default.info(`Server manager address  | ${this.managerAddress}`),s.default.info(`Server worker  address  | ${this.workerAddress}`)}getMinGasPrice(){return this.gasPrice}isCustomReplenish(){return this.customReplenish}async pingHandler(e){var t,r,a;return{relayWorkerAddress:this.workerAddress,relayManagerAddress:this.managerAddress,relayHubAddress:null!==(r=null===(t=this.relayHubContract)||void 0===t?void 0:t.address)&&void 0!==r?r:"",minGasPrice:this.getMinGasPrice().toString(),chainId:this.chainId.toString(),networkId:this.networkId.toString(),ready:null!==(a=this.isReady())&&void 0!==a&&a,version:w}}async tokenHandler(e){let t;if(void 0!==e){if(!this.trustedVerifiers.has(e.toLowerCase()))throw new Error("supplied verifier is not trusted");t=[e]}else t=Array.from(this.trustedVerifiers);const r={};for(const e of t){const t=await this.contractInteractor.createTokenHandler(e),a=await t.getAcceptedTokens();r[f.toChecksumAddress(e)]=a}return r}async verifierHandler(){return{trustedVerifiers:Array.from(this.trustedVerifiers)}}isDeployRequest(e){let t=!1;return void 0!==e.relayRequest.request.recoverer&&(t=!0),t}validateInputTypes(e){this.isDeployRequest(e)?i.default(e,i.default.object.exactShape(c.DeployTransactionRequestShape)):i.default(e,i.default.object.exactShape(c.RelayTransactionRequestShape))}validateInput(e){if(e.metadata.relayHubAddress.toLowerCase()!==this.relayHubContract.address.toLowerCase())throw new Error(`Wrong hub address.\nRelay server's hub address: ${this.relayHubContract.address}, request's hub address: ${e.metadata.relayHubAddress}\n`);if(e.relayRequest.relayData.relayWorker.toLowerCase()!==this.workerAddress.toLowerCase())throw new Error(`Wrong worker address: ${e.relayRequest.relayData.relayWorker}\n`);if(this.gasPrice>parseInt(e.relayRequest.relayData.gasPrice))throw new Error(`Unacceptable gasPrice: relayServer's gasPrice:${this.gasPrice} request's gasPrice: ${e.relayRequest.relayData.gasPrice}`)}validateVerifier(e){if(!this.isTrustedVerifier(e.relayRequest.relayData.callVerifier))throw new Error(`Invalid verifier: ${e.relayRequest.relayData.callVerifier}`)}async validateMaxNonce(e){const t=await this.transactionManager.pollNonce(this.workerAddress);if(t>e)throw new Error(`Unacceptable relayMaxNonce: ${e}. current nonce: ${t}`)}async validateRequestWithVerifier(e){const t=e.relayRequest.relayData.callVerifier;if(!this.isTrustedVerifier(t))throw new Error("Invalid verifier");let r;const a=this.isDeployRequest(e);try{r=a?await this.contractInteractor._createDeployVerifier(t):await this.contractInteractor._createRelayVerifier(t)}catch(e){const r=e;let a=`unknown verifier error: ${r.message}`;throw r.message.includes("Returned values aren't valid, did it run Out of Gas?")?a=`incompatible verifier contract: ${t}`:r.message.includes("no code at address")&&(a=`'non-existent verifier contract: ${t}`),new Error(a)}let n;if(a){const t=e;n=o.toBN(await this.contractInteractor.walletFactoryEstimateGasOfDeployCall(t))}else{const t=e,r=await this.contractInteractor.estimateDestinationContractCallGas({from:t.relayRequest.relayData.callForwarder,to:t.relayRequest.request.to,gasPrice:t.relayRequest.relayData.gasPrice,data:t.relayRequest.request.data}),a=o.toBN(t.relayRequest.request.gas).toNumber();if(r>Math.ceil(a*(1+c.constants.MAX_ESTIMATED_GAS_DEVIATION)))throw new Error("Request payload's gas parameters deviate too much fom the estimated gas for this transaction");n=o.toBN(await this.contractInteractor.estimateRelayTransactionMaxPossibleGasWithTransactionRequest(t))}try{this.isDeployRequest(e),await r.contract.methods.verifyRelayedCall(e.relayRequest,e.metadata.signature).call({from:this.workerAddress},"pending")}catch(e){throw new Error(`Verification by verifier failed: ${e.message}`)}return{maxPossibleGas:n}}async validateViewCallSucceeds(e,t,r){s.default.debug("Relay Server - Request sent to the worker"),s.default.debug("Relay Server - req: ",t);try{await e.call({from:this.workerAddress,gasPrice:t.relayRequest.relayData.gasPrice,gas:r.toString()},"pending")}catch(e){throw new Error(`relayCall (local call) reverted in server: ${e.message}`)}}async createRelayTransaction(e){if(s.default.debug(`dump request params: ${JSON.stringify(e)}`),!this.isReady())throw new Error("relay not ready");this.validateInputTypes(e),this.alerted&&(s.default.error("Alerted state: slowing down traffic"),await c.sleep(c.randomInRange(this.config.minAlertedDelayMS,this.config.maxAlertedDelayMS))),this.validateInput(e),await this.validateMaxNonce(e.metadata.relayMaxNonce);const{maxPossibleGas:t}=await this.validateRequestWithVerifier(e);s.default.debug("maxPossibleGas is",t.toString());const r=this.isDeployRequest(e)?this.relayHubContract.contract.methods.deployCall(e.relayRequest,e.metadata.signature):this.relayHubContract.contract.methods.relayCall(e.relayRequest,e.metadata.signature);await this.validateViewCallSucceeds(r,e,t);const a=await this.contractInteractor.getBlockNumber(),n={signer:this.workerAddress,serverAction:h.ServerAction.RELAY_CALL,method:r,destination:e.metadata.relayHubAddress,gasLimit:t.toNumber(),creationBlockNumber:a,gasPrice:e.relayRequest.relayData.gasPrice},i=await this.transactionManager.sendTransaction(n);return await this.replenishServer(0,a),i}async intervalHandler(){const e=Date.now();let t;return this.config.devMode||(t=setTimeout((()=>{const t=Date.now()-e;s.default.warn(n.default.bgRedBright(`Relay state: Timed-out after ${t}`)),this.lastSuccessfulRounds=0}),this.config.readyTimeout)),new Promise(((e,r)=>{this.contractInteractor.getBlock("latest").then((t=>{t.number>this.lastScannedBlock&&e(this._workerSemaphore.bind(this)(t.number))})).catch((e=>{this.emit("error",e);const t=e;s.default.error(`error in worker: ${t.message} ${t.stack}`),this.lastSuccessfulRounds=0,r(t)})).finally((()=>{clearTimeout(t)}))}))}start(){s.default.debug(`Started polling for new blocks every ${this.config.checkInterval}ms`),this.workerTask=setInterval(this.intervalHandler.bind(this),this.config.checkInterval)}stop(){if(null==this.workerTask)throw new Error("Server not started");clearInterval(this.workerTask),s.default.info("Successfully stopped polling!!")}async _workerSemaphore(e){this._workerSemaphoreOn?s.default.warn("Different worker is not finished yet, skipping this block"):(this._workerSemaphoreOn=!0,await this._worker(e).then((t=>{this.lastSuccessfulRounds++,0!==t.length&&s.default.debug(`Done handling block #${e}. Created ${t.length} transactions.`)})).finally((()=>{this._workerSemaphoreOn=!1})))}fatal(e){s.default.error("FATAL: "+e),process.exit(1)}async _initTrustedVerifiers(e=[]){this.trustedVerifiers.clear();for(const t of e)this.trustedVerifiers.add(t.toLowerCase());this.config.relayVerifierAddress===c.constants.ZERO_ADDRESS||this.trustedVerifiers.has(this.config.relayVerifierAddress.toLowerCase())||this.trustedVerifiers.add(this.config.relayVerifierAddress.toLowerCase()),this.config.deployVerifierAddress===c.constants.ZERO_ADDRESS||this.trustedVerifiers.has(this.config.deployVerifierAddress.toLowerCase())||this.trustedVerifiers.add(this.config.deployVerifierAddress.toLowerCase())}async init(){if(this.initialized)throw new Error("_init was already called");s.default.debug("Relay Server - Relay Server initializing"),await this.transactionManager._init(),s.default.debug("Relay Server - Transaction Manager initialized"),await this._initTrustedVerifiers(this.config.trustedVerifiers),this.relayHubContract=this.contractInteractor.relayHubInstance;const e=this.relayHubContract.address;s.default.debug(`Relay Server - Relay hub: ${e}`),(await this.contractInteractor.getCode(e)).length<10&&this.fatal(`No RelayHub deployed at address ${e}.`),this.registrationManager=new l.RegistrationManager(this.contractInteractor,this.transactionManager,this.txStoreManager,this,this.config,this.managerAddress,this.workerAddress),await this.registrationManager.init(),s.default.debug("Relay Server - Registration manager initialized"),this.chainId=this.contractInteractor.getChainId(),this.networkId=this.contractInteractor.getNetworkId(),s.default.debug(`Relay Server - chainId: ${this.chainId}`),s.default.debug(`Relay Server - networkId: ${this.networkId}`);const t=await this.contractInteractor.getBlock("latest");s.default.info(`Current network info:\nchainId                 | ${this.chainId}\nnetworkId               | ${this.networkId}\nlatestBlock             | ${t.number}\nlatestBlock timestamp   | ${t.timestamp}\n`),this.initialized=!0,this.registrationManager.printNotRegisteredMessage()}async replenishServer(e,t){return await d.replenishStrategy(this,e,t)}async _worker(e){if(this.initialized||await this.init(),e<=this.lastScannedBlock)throw new Error("Attempt to scan older block, aborting");return this._shouldRefreshState(e)?(this.lastRefreshBlock=e,await this._refreshGasPrice(),await this.registrationManager.refreshBalance(),this.registrationManager.balanceRequired.isSatisfied?await this._handleChanges(e):(this.setReadyState(!1),[])):[]}async _refreshGasPrice(){const e=await this.contractInteractor.getGasPrice();if(this.gasPrice=Math.floor(parseInt(e)*this.config.gasPriceFactor),0===this.gasPrice)throw new Error("Could not get gasPrice from node")}async _handleChanges(e){let t=[];const r=await this.getAllHubEventsSinceLastScan();await this._updateLatestTxBlockNumber(r);const a=await this._shouldRegisterAgain(e,r);return t=t.concat(await this.registrationManager.handlePastEvents(r,this.lastScannedBlock,e,a)),await this.transactionManager.removeConfirmedTransactions(e),await this._boostStuckPendingTransactions(e),this.lastScannedBlock=e,await this.registrationManager.isRegistered()?(await this.handlePastHubEvents(e,r),t=t.concat(await this.replenishServer(0,e)),(await this.getWorkerBalance(0)).lt(o.toBN(this.config.workerMinBalance))?(this.setReadyState(!1),t):(this.setReadyState(!0),this.alerted&&this.alertedBlock+this.config.alertedBlockDelay<e&&(s.default.warn(`Relay exited alerted state. Alerted block: ${this.alertedBlock}. Current block number: ${e}`),this.alerted=!1),t)):(this.setReadyState(!1),t)}async getManagerBalance(){return o.toBN(await this.contractInteractor.getBalance(this.managerAddress,"pending"))}async getWorkerBalance(e){return o.toBN(await this.contractInteractor.getBalance(this.workerAddress,"pending"))}async _shouldRegisterAgain(e,t){const r=await this.txStoreManager.isActionPending(h.ServerAction.RELAY_CALL)||await this.txStoreManager.isActionPending(h.ServerAction.REGISTER_SERVER);if(0===this.config.registrationBlockRate||r)return s.default.debug(`_shouldRegisterAgain returns false isPendingActivityTransaction=${r} registrationBlockRate=${this.config.registrationBlockRate}`),!1;const a=this._getLatestTxBlockNumber(),n=e-a>=this.config.registrationBlockRate;return n||s.default.debug(`_shouldRegisterAgain registrationExpired=${n} currentBlock=${e} latestTxBlockNumber=${a} registrationBlockRate=${this.config.registrationBlockRate}`),n}_shouldRefreshState(e){return e-this.lastRefreshBlock>=this.config.refreshStateTimeoutBlocks||!this.isReady()}async handlePastHubEvents(e,t){for(const r of t)switch(r.event){case c.TransactionRejectedByRecipient:s.default.debug("handle TransactionRejectedByRecipient event",r),await this._handleTransactionRejectedByRecipientEvent(e);break;case c.TransactionRelayed:s.default.debug(`handle TransactionRelayed event: ${JSON.stringify(r)}`),await this._handleTransactionRelayedEvent(r)}}async getAllHubEventsSinceLastScan(){const e=[c.address2topic(this.managerAddress)],t={fromBlock:this.lastScannedBlock+1,toBlock:"latest"},r=await this.contractInteractor.getPastEventsForHub(e,t);return 0!==r.length&&s.default.debug(`Found ${r.length} events since last scan`),r}async _handleTransactionRelayedEvent(e){}async _handleTransactionRejectedByRecipientEvent(e){this.alerted=!0,this.alertedBlock=e,s.default.error(`Relay entered alerted state. Block number: ${e}`)}_getLatestTxBlockNumber(){var e,t;return null!==(t=null===(e=this.lastMinedActiveTransaction)||void 0===e?void 0:e.blockNumber)&&void 0!==t?t:-1}async _updateLatestTxBlockNumber(e){var t,r;const a=c.getLatestEventData(e);null!=a&&(this.lastMinedActiveTransaction=a,s.default.debug(`found newer block ${null===(t=this.lastMinedActiveTransaction)||void 0===t?void 0:t.blockNumber}`)),null==this.lastMinedActiveTransaction&&(this.lastMinedActiveTransaction=await this._queryLatestActiveEvent(),s.default.debug(`queried node for last active server event, found in block ${null===(r=this.lastMinedActiveTransaction)||void 0===r?void 0:r.blockNumber}`))}async _queryLatestActiveEvent(){const e=await this.contractInteractor.getPastEventsForHub([c.address2topic(this.managerAddress)],{fromBlock:1});return c.getLatestEventData(e)}async _boostStuckPendingTransactions(e){const t=new Map,r=await this._boostStuckTransactionsForManager(e);for(const[e,a]of r)t.set(e,a);for(const r of[0]){const a=await this._boostStuckTransactionsForWorker(e,r);for(const[e,r]of a)t.set(e,r)}return t}async _boostStuckTransactionsForManager(e){return await this.transactionManager.boostUnderpricedPendingTransactionsForSigner(this.managerAddress,e)}async _boostStuckTransactionsForWorker(e,t){const r=this.workerAddress;return await this.transactionManager.boostUnderpricedPendingTransactionsForSigner(r,e)}isTrustedVerifier(e){return this.trustedVerifiers.has(e.toLowerCase())}isReady(){return!(this.lastSuccessfulRounds<this.config.successfulRoundsForReady)&&this.ready}setReadyState(e){if(this.isReady()!==e)if(e)if(this.lastSuccessfulRounds<this.config.successfulRoundsForReady){const e=this.config.successfulRoundsForReady-this.lastSuccessfulRounds;s.default.warn(n.default.yellow(`Relayer state: almost READY (in ${e} rounds)`))}else s.default.warn(n.default.greenBright("Relayer state: READY"));else s.default.warn(n.default.redBright("Relayer state: NOT-READY"));this.ready=e}}t.RelayServer=m},851:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.replenishStrategy=void 0;const a=r(784),n=r(51),s=r(565);t.replenishStrategy=async function(e,t,r){let i=[];if(e.isCustomReplenish())throw new Error("No custom replenish function found, to remove this error please add the custom replenish implementation here deleting this line.");return i=await async function(e,t,r){const i=[];let o=await e.getManagerBalance();if(e.workerBalanceRequired.currentValue=await e.getWorkerBalance(t),o.gte(a.toBN(e.config.managerTargetBalance.toString()))&&e.workerBalanceRequired.isSatisfied)return i;o=await e.getManagerBalance();const c=!e.workerBalanceRequired.isSatisfied,d=await e.txStoreManager.isActionPending(s.ServerAction.VALUE_TRANSFER,e.workerAddress);if(c&&!d){const t=a.toBN(e.config.workerTargetBalance.toString()).sub(e.workerBalanceRequired.currentValue);if(console.log(`== replenishServer: mgr balance=${o.toString()}\n        \n${e.workerBalanceRequired.description}\n refill=${t.toString()}`),t.lt(o.sub(a.toBN(e.config.managerMinBalance)))){console.log("Replenishing worker balance by manager rbtc balance");const o={signer:e.managerAddress,serverAction:s.ServerAction.VALUE_TRANSFER,destination:e.workerAddress,value:a.toHex(t),creationBlockNumber:r,gasLimit:n.defaultEnvironment.mintxgascost},{transactionHash:c}=await e.transactionManager.sendTransaction(o);i.push(c)}else{const r=`== replenishServer: can't replenish: mgr balance too low ${o.toString()} refill=${t.toString()}`;e.emit("fundingNeeded",r),console.log(r)}}return i}(e,t,r),i}},72:function(e,t,r){var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.configureServer=t.resolveServerConfig=t.parseServerConfig=t.filterMembers=t.entriesToObj=t.filterType=void 0;const o=i(r(996)),c=s(r(747)),d=r(51),l=r(342);r(748).install({errorFormatterForce:!0});const u={alertedBlockDelay:0,minAlertedDelayMS:0,maxAlertedDelayMS:0,relayHubAddress:d.constants.ZERO_ADDRESS,relayVerifierAddress:d.constants.ZERO_ADDRESS,deployVerifierAddress:d.constants.ZERO_ADDRESS,trustedVerifiers:[],gasPriceFactor:1,registrationBlockRate:0,workerMinBalance:1e15,workerTargetBalance:3e15,managerMinBalance:1e15,managerMinStake:"1",managerTargetBalance:3e15,minHubWithdrawalBalance:1e15,checkInterval:1e4,readyTimeout:3e4,devMode:!1,customReplenish:!1,logLevel:1,url:"http://localhost:8090",rskNodeUrl:"",port:0,versionRegistryAddress:d.constants.ZERO_ADDRESS,workdir:"",refreshStateTimeoutBlocks:5,pendingTransactionTimeoutBlocks:30,successfulRoundsForReady:3,confirmationsNeeded:12,retryGasPriceFactor:1.2,defaultGasLimit:5e5,maxGasPrice:1e11.toString(),estimateGasFactor:1.2},h={config:"string",url:"string",port:"number",versionRegistryAddress:"string",versionRegistryDelayPeriod:"number",relayHubId:"string",relayHubAddress:"string",gasPriceFactor:"number",rskNodeUrl:"string",workdir:"string",checkInterval:"number",readyTimeout:"number",devMode:"boolean",customReplenish:"boolean",logLevel:"number",registrationBlockRate:"number",alertedBlockDelay:"number",workerMinBalance:"number",workerTargetBalance:"number",managerMinBalance:"number",managerTargetBalance:"number",minHubWithdrawalBalance:"number",defaultGasLimit:"number",trustedVerifiers:"string",relayVerifierAddress:"string",deployVerifierAddress:"string"};function g(e){throw new Error(e)}function f(e,t){return Object.entries(e).flatMap((e=>e[1]===t?[e[0]]:[]))}function y(e){return e.reduce(((e,[t,r])=>Object.assign(Object.assign({},e),{[t]:r})),{})}function w(e,t){return y(Object.entries(e).filter((e=>null!=t[e[0]])))}function m([e,t]){const r=h[e];switch(void 0===r&&g(`unexpected param ${e}=${t}`),r){case"boolean":if("true"===t||!0===t)return[e,!0];if("false"===t||!1===t)return[e,!1];break;case"number":{const r=parseInt(t);if(!isNaN(r))return[e,r];break}default:return[e,t]}g(`Invalid ${r}: ${e} = ${t}`)}t.filterType=f,t.entriesToObj=y,t.filterMembers=w,t.parseServerConfig=function(e,t){const r=w(t,h),a=o.default(e,{string:f(h,"string"),default:r});a._.length>0&&g(`unexpected param(s) ${a._.join(",")}`),delete a._;let n={};const s=a.config;null!=s&&(c.existsSync(s)||g(`unable to read config file "${s}"`),n=JSON.parse(c.readFileSync(s,"utf8")));const i=Object.assign(Object.assign({},n),a);return y(Object.entries(i).map(m))},t.resolveServerConfig=async function(e,t){var r,a;const n=new d.ContractInteractor(t,l.configure({relayHubAddress:e.relayHubAddress}));if(null!=e.versionRegistryAddress){null!=e.relayHubAddress&&g("missing param: must have either relayHubAddress or versionRegistryAddress");const s=null!==(r=e.relayHubId)&&void 0!==r?r:g("missing param: relayHubId to read from VersionRegistry");n.validateAddress(e.versionRegistryAddress,"Invalid param versionRegistryAddress: "),await n.isContractDeployed(e.versionRegistryAddress)||g("Invalid param versionRegistryAddress: no contract at address "+e.versionRegistryAddress);const i=new d.VersionRegistry(t,e.versionRegistryAddress),{version:o,value:c,time:l}=await i.getVersion(s,null!==(a=e.versionRegistryDelayPeriod)&&void 0!==a?a:0);n.validateAddress(c,`Invalid param relayHubId ${s} @ ${o}: not an address:`),console.log(`Using RelayHub ID:${s} version:${o} address:${c} . created at: ${new Date(1e3*l).toString()}`),e.relayHubAddress=c}else null==e.relayHubAddress&&g("missing param: must have either relayHubAddress or versionRegistryAddress"),n.validateAddress(e.relayHubAddress,'invalid param: "relayHubAddress" is not a valid address:');return await n.isContractDeployed(e.relayHubAddress)||g(`RelayHub: no contract at address ${e.relayHubAddress}`),null==e.url&&g("missing param: url"),null==e.workdir&&g("missing param: workdir"),Object.assign(Object.assign({},u),e)},t.configureServer=function(e){return Object.assign({},u,e)}},565:function(e,t,r){var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.createStoredTransaction=t.ServerAction=void 0;const i=s(r(519));var o;(o=t.ServerAction||(t.ServerAction={}))[o.REGISTER_SERVER=0]="REGISTER_SERVER",o[o.ADD_WORKER=1]="ADD_WORKER",o[o.RELAY_CALL=2]="RELAY_CALL",o[o.VALUE_TRANSFER=3]="VALUE_TRANSFER",o[o.DEPOSIT_WITHDRAWAL=4]="DEPOSIT_WITHDRAWAL",o[o.PENALIZATION=5]="PENALIZATION",t.createStoredTransaction=function(e,t){const r={to:i.bufferToHex(e.to),gas:i.bufferToInt(e.gasLimit),gasPrice:i.bufferToInt(e.gasPrice),data:i.bufferToHex(e.data),nonce:i.bufferToInt(e.nonce),txId:i.bufferToHex(e.hash())};return Object.assign({},r,t)}},516:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.TransactionManager=void 0;const n=a(r(742)),s=a(r(242)),i=a(r(732)),o=r(989),c=r(865),d=r(565);t.TransactionManager=class{constructor(e,t){this.nonceMutex=new o.Mutex,this.nonces={},this.contractInteractor=e.contractInteractor,this.txStoreManager=e.txStoreManager,this.workersKeyManager=e.workersKeyManager,this.managerKeyManager=e.managerKeyManager,this.config=t,this._initNonces()}_initNonces(){this.nonces[this.managerKeyManager.getAddress(0)]=0,this.nonces[this.workersKeyManager.getAddress(0)]=0}async _init(){if(this.rawTxOptions=this.contractInteractor.getRawTxOptions(),null==this.rawTxOptions)throw new Error("_init failed for TransactionManager, was ContractInteractor properly initialized?")}printBoostedTransactionLog(e,t,r,a){const o=new n.default(r).toGwei().toFixed(4);i.default.info(`Boosting stale transaction:\nhash         | ${e}\ngasPrice     | ${r} (${o} gwei) ${a?s.default.red("k256"):""}\ncreated at   | block #${t}\n`)}printSendTransactionLog(e,t){const r=0===e.value.length?"0":parseInt("0x"+e.value.toString("hex")).toString(),a=0===e.nonce.length?"0":parseInt("0x"+e.nonce.toString("hex")),s=parseInt("0x"+e.gasPrice.toString("hex")),o=new n.default(r).toEth().toFixed(4),c=new n.default(s).toGwei().toFixed(4);i.default.info(`Broadcasting transaction:\nhash         | 0x${e.hash().toString("hex")}\nfrom         | ${t}\nto           | 0x${e.to.toString("hex")}\nvalue        | ${r} (${o} RBTC)\nnonce        | ${a}\ngasPrice     | ${s} (${c} gwei)\ngasLimit     | ${parseInt("0x"+e.gasLimit.toString("hex"))}\ndata         | 0x${e.data.toString("hex")}\n`)}async attemptEstimateGas(e,t,r){try{const e=await t.estimateGas({from:r});return Math.round(parseInt(e)*this.config.estimateGasFactor)}catch(t){i.default.error(`Failed to estimate gas for method ${e}\n. Using default ${this.config.defaultGasLimit}`,t.message)}return this.config.defaultGasLimit}async sendTransaction({signer:e,method:t,destination:r,value:a="0x",gasLimit:n,gasPrice:s,creationBlockNumber:i,serverAction:o}){var l;const u=null!==(l=null==t?void 0:t.encodeABI())&&void 0!==l?l:"0x",h=parseInt(null!=s?s:await this.contractInteractor.getGasPrice()),g=await this.nonceMutex.acquire();let f,y;try{const t=await this.pollNonce(e),s=new c.Transaction({to:r,value:a,gasLimit:n,gasPrice:h,data:Buffer.from(u.slice(2),"hex"),nonce:t},this.rawTxOptions);f=(this.managerKeyManager.isSigner(e)?this.managerKeyManager:this.workersKeyManager).signTransaction(e,s);const l={from:e,attempts:1,serverAction:o,creationBlockNumber:i};y=d.createStoredTransaction(s,l),this.nonces[e]++,await this.txStoreManager.putTx(y,!1),this.printSendTransactionLog(s,e)}finally{g()}const w=await this.contractInteractor.broadcastTransaction(f);if(w.toLowerCase()!==y.txId.toLowerCase())throw new Error(`txhash mismatch: from receipt: ${w} from txstore:${y.txId}`);return{transactionHash:w,signedTx:f}}async updateTransactionWithMinedBlock(e,t){const r=Object.assign({},e,{minedBlockNumber:t});await this.txStoreManager.putTx(r,!0)}async updateTransactionWithAttempt(e,t,r){const a={attempts:t.attempts+1,boostBlockNumber:r,from:t.from,serverAction:t.serverAction,creationBlockNumber:t.creationBlockNumber,minedBlockNumber:t.minedBlockNumber},n=d.createStoredTransaction(e,a);return await this.txStoreManager.putTx(n,!0),n}async resendTransaction(e,t,r,a){const n=new c.Transaction({to:e.to,gasLimit:e.gas,gasPrice:r,data:e.data,nonce:e.nonce},this.rawTxOptions),s=(this.managerKeyManager.isSigner(e.from)?this.managerKeyManager:this.workersKeyManager).signTransaction(e.from,n),o=await this.updateTransactionWithAttempt(n,e,t);this.printBoostedTransactionLog(e.txId,e.creationBlockNumber,e.gasPrice,a),this.printSendTransactionLog(n,e.from);const d=await this.contractInteractor.getTransactionCount(e.from);i.default.debug(`Current account nonce for ${e.from} is ${d}`);const l=await this.contractInteractor.broadcastTransaction(s);if(l.toLowerCase()!==o.txId.toLowerCase())throw new Error(`txhash mismatch: from receipt: ${l} from txstore:${o.txId}`);return{transactionHash:l,signedTx:s}}_resolveNewGasPrice(e){let t=!1,r=e*this.config.retryGasPriceFactor;return r>parseInt(this.config.maxGasPrice)&&(t=!0,r=parseInt(this.config.maxGasPrice)),{newGasPrice:r,isMaxGasPriceReached:t}}async pollNonce(e){const t=await this.contractInteractor.getTransactionCount(e,"pending");return t>this.nonces[e]&&(i.default.warn("NONCE FIX for signer=",e,": nonce=",t,this.nonces[e]),this.nonces[e]=t),this.nonces[e]}async removeConfirmedTransactions(e){const t=await this.txStoreManager.getAll();if(0!==t.length){i.default.debug(`Total of ${t.length} transactions are not confirmed yet, checking...`);for(const r of t)if(null==r.minedBlockNumber||e-r.minedBlockNumber>=this.config.confirmationsNeeded){const t=await this.contractInteractor.getTransaction(r.txId);if(null==t){i.default.warn(`warning: failed to fetch receipt for tx ${r.txId}`);continue}if(null==t.blockNumber){i.default.warn(`warning: null block number in receipt for ${r.txId}`);continue}const a=e-t.blockNumber;if(t.blockNumber!==r.minedBlockNumber&&(null!=r.minedBlockNumber&&i.default.warn(`transaction ${r.txId} was moved between blocks`),a<this.config.confirmationsNeeded)){i.default.debug(`Tx ${r.txId} was mined but only has ${a} confirmations`),await this.updateTransactionWithMinedBlock(r,t.blockNumber);continue}i.default.debug(`removing tx number ${t.nonce} sent by ${t.from} with ${a} confirmations`),await this.txStoreManager.removeTxsUntilNonce(t.from,t.nonce)}}}async boostUnderpricedPendingTransactionsForSigner(e,t){var r;const a=new Map,n=await this.txStoreManager.getAllBySigner(e);if(0===n.length)return a;const s=await this.contractInteractor.getTransactionCount(e),o=n[0];if(o.nonce<s)return i.default.debug(`${e} : transaction is mined, awaiting confirmations. Account nonce: ${s}, oldest transaction: nonce: ${o.nonce} txId: ${o.txId}`),a;if(t-(null!==(r=o.boostBlockNumber)&&void 0!==r?r:o.creationBlockNumber)<this.config.pendingTransactionTimeoutBlocks)return i.default.debug(`${e} : awaiting transaction with ID: ${o.txId} to be mined. creationBlockNumber: ${o.creationBlockNumber} nonce: ${s}`),a;const{newGasPrice:c,isMaxGasPriceReached:d}=this._resolveNewGasPrice(o.gasPrice),l=n.filter((e=>e.gasPrice<c));for(const r of l){const n=await this.resendTransaction(r,t,c,d);a.set(r.txId,n),i.default.debug(`Replaced transaction: nonce: ${r.nonce} sender: ${e} | ${r.txId} => ${n.transactionHash}`),r.attempts>2&&i.default.debug(`resend ${e}: Sent tx ${r.attempts} times already`)}return a}}},697:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.TxStoreManager=t.TXSTORE_FILENAME=void 0;const n=a(r(825)),s=a(r(732)),i=a(r(349)),o=r(51);t.TXSTORE_FILENAME="txstore.db",t.TxStoreManager=class{constructor({workdir:e="/tmp/test/",inMemory:r=!1}){this.txstore=new n.default({filename:r?void 0:`${e}/${t.TXSTORE_FILENAME}`,autoload:!0,timestampData:!0}),this.txstore.asyncEnsureIndex({fieldName:"txId",unique:!0}),this.txstore.asyncEnsureIndex({fieldName:"nonceSigner",unique:!0}),s.default.info("Server database location:",r?"memory":`${e}/${t.TXSTORE_FILENAME}`)}async putTx(e,t=!1){if(!e||!e.txId||!e.attempts||void 0===e.nonce)throw new Error("Invalid tx:"+JSON.stringify(e));const r={nonce:e.nonce,signer:e.from.toLowerCase()},a=Object.assign(Object.assign({},e),{txId:e.txId.toLowerCase(),nonceSigner:r}),n=await this.txstore.asyncFindOne({nonceSigner:a.nonceSigner});n&&t?await this.txstore.asyncUpdate({txId:n.txId},{$set:a}):await this.txstore.asyncInsert(a)}async getTxByNonce(e,t){return i.default(t,i.default.any(i.default.number,i.default.string)),i.default(e,i.default.string),await this.txstore.asyncFindOne({nonceSigner:{signer:e.toLowerCase(),nonce:t}})}async getTxById(e){return i.default(e,i.default.string),await this.txstore.asyncFindOne({txId:e.toLowerCase()})}async getTxsUntilNonce(e,t){return await this.txstore.asyncFind({$and:[{"nonceSigner.nonce":{$lte:t}},{"nonceSigner.signer":e.toLowerCase()}]})}async removeTxsUntilNonce(e,t){return i.default(t,i.default.number),i.default(e,i.default.string),await this.txstore.asyncRemove({$and:[{"nonceSigner.nonce":{$lte:t}},{"nonceSigner.signer":e.toLowerCase()}]},{multi:!0})}async clearAll(){await this.txstore.asyncRemove({},{multi:!0})}async getAllBySigner(e){return(await this.txstore.asyncFind({"nonceSigner.signer":e.toLowerCase()})).sort((function(e,t){return e.nonce-t.nonce}))}async getAll(){return(await this.txstore.asyncFind({})).sort((function(e,t){return e.nonce-t.nonce}))}async isActionPending(e,t){return null!=(await this.getAll()).find((r=>null==r.minedBlockNumber&&r.serverAction===e&&(null==t||o.isSameAddress(r.to,t))))}}},607:function(e,t,r){var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r),Object.defineProperty(e,a,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(472),t),n(r(959),t),n(r(93),t),n(r(723),t),n(r(851),t),n(r(260),t),n(r(72),t),n(r(565),t),n(r(516),t),n(r(697),t)},260:function(e,t,r){var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const n=a(r(747)),s=a(r(409)),i=r(472),o=r(723),c=r(959),d=r(697),l=r(51),u=r(342),h=r(72),g=a(r(732));function f(e){console.error(e),process.exit(1)}!async function(){let e,t,r=[];console.log("Starting Enveloping Relay Server process...\n");try{const a=await h.parseServerConfig(process.argv.slice(2),process.env);console.log(a),null==a.rskNodeUrl&&f("missing rskNodeUrl"),void 0!==a.trustedVerifiers&&null!=a.trustedVerifiers&&""!==a.trustedVerifiers&&(r=JSON.parse(a.trustedVerifiers)),t=new s.default.providers.HttpProvider(a.rskNodeUrl),g.default.debug("runServer() - web3Provider done"),e=await h.resolveServerConfig(a,t),g.default.debug("runServer() - config done"),r.length>0&&(e.trustedVerifiers=r)}catch(e){f(e.message)}const{devMode:a,workdir:y}=e;a&&n.default.existsSync(`${y}/${d.TXSTORE_FILENAME}`)&&n.default.unlinkSync(`${y}/${d.TXSTORE_FILENAME}`);const w=new c.KeyManager(1,y+"/manager"),m=new c.KeyManager(1,y+"/workers");g.default.debug("runServer() - manager and workers configured");const v=new d.TxStoreManager({workdir:y}),p=new l.ContractInteractor(t,u.configure({relayHubAddress:e.relayHubAddress,deployVerifierAddress:e.deployVerifierAddress,relayVerifierAddress:e.relayVerifierAddress}));await p.init(),g.default.debug("runServer() - contract interactor initilized");const k={txStoreManager:v,managerKeyManager:w,workersKeyManager:m,contractInteractor:p},b=new o.RelayServer(e,k);await b.init(),g.default.debug("runServer() - Relay Server initialized"),new i.HttpServer(e.port,b).start(),g.default.debug("runServer() - Relay Server started")}()},342:e=>{e.exports=require("@rsksmart/rif-relay-client")},51:e=>{e.exports=require("@rsksmart/rif-relay-common")},989:e=>{e.exports=require("async-mutex")},473:e=>{e.exports=require("body-parser")},242:e=>{e.exports=require("chalk")},479:e=>{e.exports=require("cors")},865:e=>{e.exports=require("ethereumjs-tx")},519:e=>{e.exports=require("ethereumjs-util")},364:e=>{e.exports=require("ethereumjs-wallet")},742:e=>{e.exports=require("ethval")},614:e=>{e.exports=require("events")},127:e=>{e.exports=require("express")},747:e=>{e.exports=require("fs")},144:e=>{e.exports=require("jsonrpc-lite")},732:e=>{e.exports=require("loglevel")},996:e=>{e.exports=require("minimist")},825:e=>{e.exports=require("nedb-async")},349:e=>{e.exports=require("ow")},748:e=>{e.exports=require("source-map-support")},409:e=>{e.exports=require("web3")},784:e=>{e.exports=require("web3-utils")}},t={},r=function r(a){var n=t[a];if(void 0!==n)return n.exports;var s=t[a]={exports:{}};return e[a].call(s.exports,s,s.exports,r),s.exports}(607);module.exports=r})();